import re
import json
import os
from pypdf import PdfReader

# Nome del file PDF (assicurati sia corretto)
PDF_NAME = "SY0-701.pdf"

def pulisci_testo_base(testo):
    """Pulizia preliminare del testo grezzo."""
    # Rimuove intestazioni di pagina frequenti
    testo = re.sub(r'--- PAGE \d+ ---', '', testo)
    testo = re.sub(r'SY0-701', '', testo)
    testo = re.sub(r'CompTIA Security\+ Exam', '', testo)
    
    # Rimuove doppi spazi e tabulazioni strane
    testo = testo.replace('\t', ' ').replace('\r', '')
    
    # TRUCCO: A volte le opzioni sono attaccate (es: "text.A. Option"). 
    # Forziamo uno spazio prima di A., B., C., etc. se sono a inizio riga logica o dopo un punto
    testo = re.sub(r'([a-z0-9])([A-F]\.)', r'\1 \n\2', testo)
    
    return testo.strip()

def estrai_domande(pdf_path):
    if not os.path.exists(pdf_path):
        print(f"‚ùå ERRORE: Non trovo il file '{pdf_path}' nella cartella.")
        return []

    try:
        reader = PdfReader(pdf_path)
    except Exception as e:
        print(f"‚ùå Errore lettura PDF: {e}")
        return []

    full_text = ""
    print(f"üìñ Lettura di {len(reader.pages)} pagine in corso...")
    
    for page in reader.pages:
        txt = page.extract_text()
        if txt:
            full_text += txt + "\n"
    
    full_text = pulisci_testo_base(full_text)
    
    # Divide le domande cercando "QUESTION: N"
    # Usa un regex robusto che cattura anche se c'√® spazio strano "QUESTION : 1"
    pattern = re.split(r'(QUESTION\s*:\s*\d+)', full_text)
    
    domande_output = []
    skipped_count = 0
    log_errori = []

    # Il primo elemento √® testo prima della prima domanda, lo ignoriamo
    # Poi abbiamo coppie: [HEADER, CONTENT, HEADER, CONTENT...]
    for i in range(1, len(pattern), 2):
        header = pattern[i].strip()        # Es: QUESTION: 1
        content = pattern[i+1].strip()     # Tutto il resto
        
        q_id = header.replace("QUESTION", "").replace(":", "").strip()

        # 1. Cerca la risposta corretta (Answer: X o Answer(s): X)
        # Cerchiamo alla fine del blocco testo
        match_risposta = re.search(r'Answer(?:\(s\))?\s*:\s*([A-F,\s]+)', content, re.IGNORECASE)
        
        if not match_risposta:
            skipped_count += 1
            log_errori.append(f"ID {q_id}: Nessuna risposta trovata (probabile Drag&Drop o Istruzioni)")
            continue 

        risposta_grezza = match_risposta.group(1).strip()
        corretta = [x.strip() for x in re.split(r'[,\s]+', risposta_grezza) if x.strip()]
        
        # 2. Separa il testo della domanda dalle opzioni
        # Prendiamo tutto ci√≤ che c'√® PRIMA della scritta "Answer..."
        content_no_answer = content[:match_risposta.start()].strip()
        
        # 3. Estrazione Opzioni (A., B., C., ...)
        # Usiamo un regex che cerca "Lettera + Punto + Spazio" o fine riga
        # Split restituisce: [TestoDomanda, "A.", "TestoA", "B.", "TestoB", ...]
        parts = re.split(r'([A-F]\.)', content_no_answer)
        
        if len(parts) < 3:
            skipped_count += 1
            log_errori.append(f"ID {q_id}: Formato opzioni non riconosciuto (Mancano A. B. C.)")
            continue
            
        quesito = parts[0].strip()
        
        # Puliamo il quesito da "a capo" inutili che spezzano le frasi a met√†
        lines = quesito.split('\n')
        quesito_pulito = " ".join([l.strip() for l in lines if l.strip()])
        
        opzioni = []
        lettere = []
        
        # parts[1] = "A.", parts[2] = "Testo opzione A", parts[3] = "B.", parts[4] = "Testo opzione B"...
        for k in range(1, len(parts), 2):
            let = parts[k].replace('.', '').strip() # "A"
            text_opt = parts[k+1].strip()
            
            # Pulizia testo opzione (rimuove a capo interni)
            text_opt = " ".join([t.strip() for t in text_opt.split('\n')])
            
            opzioni.append(text_opt)
            lettere.append(let)
        
        # Controllo finale validit√†
        if not opzioni or not corretta:
            skipped_count += 1
            continue

        domande_output.append({
            "id": q_id,
            "domanda": quesito_pulito,
            "opzioni": opzioni,          
            "lettere": lettere,  
            "corretta": corretta         
        })

    # Scrittura Log errori per debug
    with open("log_errori.txt", "w", encoding="utf-8") as f:
        f.write("\n".join(log_errori))

    print(f"‚ö†Ô∏è Domande saltate: {skipped_count} (vedi log_errori.txt)")
    return domande_output

if __name__ == "__main__":
    data = estrai_domande(PDF_NAME)
    if data:
        with open("database_domande.json", "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
        print(f"‚úÖ SUCCESSO! {len(data)} domande valide salvate in 'database_domande.json'.")
        print("   Ora puoi avviare il bot.")
    else:
        print("‚ùå Nessuna domanda estratta.")
